package de.uhd.ifi.se.acgen.generator;

import java.util.ArrayList;
import java.util.Arrays;
import java.util.Collections;
import java.util.Comparator;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Set;

import de.uhd.ifi.se.acgen.exception.TokenNotFoundException;
import de.uhd.ifi.se.acgen.model.AcceptanceCriterion;
import de.uhd.ifi.se.acgen.model.AcceptanceCriterionType;
import de.uhd.ifi.se.acgen.model.UserStory;
import edu.stanford.nlp.coref.CorefCoreAnnotations;
import edu.stanford.nlp.coref.data.CorefChain;
import edu.stanford.nlp.coref.data.CorefChain.CorefMention;
import edu.stanford.nlp.ling.IndexedWord;
import edu.stanford.nlp.pipeline.CoreDocument;
import edu.stanford.nlp.pipeline.CoreSentence;
import edu.stanford.nlp.pipeline.StanfordCoreNLP;
import edu.stanford.nlp.semgraph.SemanticGraph;

/**
 * Generates acceptance criteria for a user story. The acceptance criteria 
 * generated by this generator follow Gherkin syntax, i.e.: “GIVEN
 * [precondition] WHEN [action] THEN [expected results]”.
 * 
 * @see Generator
 */
public class GherkinGenerator implements Generator {

    // Those words start a conditional sentence or denote a temporal relation
    // between two actions, which can be used to derive actions.
    List<String> conditionalStarterStrings = Arrays.asList("if", "when", "once", "whenever", "after", "during");

    /**
     * {@inheritDoc}
     * 
     * The acceptance criteria generated by this method follow Gherkin syntax, 
     * i.e.: “GIVEN [precondition] WHEN [action] THEN [expected results]”.
     * 
     * @see Generator
     */
    public List<AcceptanceCriterion> generate(UserStory userStory, boolean debug) throws TokenNotFoundException {
        String userStoryString = userStory.getUserStoryString();
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();

        // Preprocess the user story string
        userStoryString = preprocessing(userStoryString);
        if (debug) {
            // If debug information have been requested, the preprocessed user
            // story string is added as a debug message.
            acceptanceCriteria.add(new AcceptanceCriterion(userStoryString, AcceptanceCriterionType.DEBUG));
        }

        // Set up the NLP pipeline and annotate the preprocessed user story
        // string
        Properties props = new Properties();
        props.setProperty("annotators", "tokenize,ssplit,pos,lemma,ner,depparse,regexner");
        props.setProperty("ssplit.isOneSentence", "true");
        props.setProperty("regexner.mapping", "src/main/java/de/uhd/ifi/se/acgen/generator/regexner/ui-mapping.txt");
        StanfordCoreNLP pipeline = new StanfordCoreNLP(props);
        CoreDocument document = new CoreDocument(userStoryString);
        pipeline.annotate(document);
        CoreSentence userStorySentence = document.sentences().get(0);

        // Generate acceptance criteria of various types
        acceptanceCriteria.addAll(extractRolePrecondition(userStorySentence, userStoryString));
        acceptanceCriteria.addAll(extractUIPrecondition(userStorySentence, userStoryString));
        acceptanceCriteria.addAll(extractActions(userStorySentence, userStoryString));
        acceptanceCriteria.addAll(extractResults(userStorySentence, userStoryString, acceptanceCriteria));

        // Sort acceptance criteria so that WHEN – THEN relations are
        // represented correctly
        Collections.sort(acceptanceCriteria);

        // Resolve duplicate information that occurs multiple times in
        // different acceptance criteria.
        acceptanceCriteria = resolveDuplicateInformation(acceptanceCriteria);

        return acceptanceCriteria;
    }

    /**
     * Preprocesses the user story, i.e., convert the user story to third
     * person.
     * 
     * @param userStoryString a string containing the user story
     * @return a string containing the preprocessed user story
     * @throws TokenNotFoundException if an essential part of a user story such
     * as the verb or the subject could not be identified by the Stanford
     * CoreNLP tools.
     * 
     * @see GherkinGenerator#generate
     */
    private String preprocessing(String userStoryString) throws TokenNotFoundException {
        // Set up the NLP pipeline and annotate the original user story string
        Properties props = new Properties();
        props.setProperty("annotators", "tokenize,ssplit,pos,lemma,ner,depparse,coref");
        props.setProperty("ssplit.isOneSentence", "true");
        StanfordCoreNLP pipeline = new StanfordCoreNLP(props);
        CoreDocument document = new CoreDocument(userStoryString);
        pipeline.annotate(document);
        CoreSentence userStorySentence = document.sentences().get(0);

        Map<Integer, String> replacements = new HashMap<Integer, String>();

        // Generate a map which shows where to replace which words by which
        // other words in order to convert the user story to third person.
        replacements.putAll(switchToThirdPerson(document, userStorySentence));

        // Return a string where the replacements determined before are
        // implemented.
        return replaceWordsInSentence(userStorySentence, userStoryString, replacements);
    }

    /**
     * Converts a given sentence to third person.
     * 
     * @param document a {@code CoreDocument} containing the NLP analysis
     * result of the user story
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return a map which shows where to replace which words by which other
     * words in order to convert the user story to third person.
     * @throws TokenNotFoundException if an essential part of a user story such
     * as the verb or the subject could not be identified by the Stanford
     * CoreNLP tools.
     * 
     * @see GherkinGenerator#preprocessing
     */
    private Map<Integer, String> switchToThirdPerson(CoreDocument document, CoreSentence sentence) throws TokenNotFoundException {
        Map<Integer, String> newReplacements = new HashMap<Integer, String>();

        // Identify the subject of the sentence, which must be the “I” from the
        // “I want” expression of the user story.
        IndexedWord subject = identifySubject(sentence);

        // Using the Coreference annotator from Stanford CoreNLP, identify all
        // words (e.g. pronouns) that refer to the same entity as the subject
        // of the sentence (i.e., the “I” described above).
        List<IndexedWord> coreferencesOfSubject =  getCoreferencesOfWord(document, subject);
        if (coreferencesOfSubject.isEmpty()) {
            // If no other references to the subject are found, add the subject
            // itself to the empty list so that it can be handled accordingly.
            coreferencesOfSubject.add(subject);
        }
        for (IndexedWord coreferenceOfSubject : coreferencesOfSubject) {
            // If the subject or one of its references is a known pronoun,
            // replace it with the third person expression “the user” in the
            // correct grammatical form
            if (coreferenceOfSubject.word().equalsIgnoreCase("I")) {
                newReplacements.put(coreferenceOfSubject.index(), "the user");
                // If the word is a subject which has verbs associated to it,
                // the verbs must be converted to third person as well.
                newReplacements.putAll(addSToVerbOfSubject(sentence, coreferenceOfSubject));
            } else if (coreferenceOfSubject.word().equalsIgnoreCase("me")) {
                newReplacements.put(coreferenceOfSubject.index(), "the user");
            } else if (coreferenceOfSubject.word().equalsIgnoreCase("my")) {
                newReplacements.put(coreferenceOfSubject.index(), "the user’s");
            } else if (coreferenceOfSubject.word().equalsIgnoreCase("mine")) {
                newReplacements.put(coreferenceOfSubject.index(), "the user’s");
            } else if (coreferenceOfSubject.word().equalsIgnoreCase("myself")) {
                newReplacements.put(coreferenceOfSubject.index(), "themself");
            }
        }
        return newReplacements;
    }

    /**
     * Identifies the subject of the sentence, which must be the “I” from the
     * “I want” expression of the user story.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the subject of the sentence
     * @throws TokenNotFoundException if an essential part of a user story such
     * as the verb or the subject could not be identified by the Stanford
     * CoreNLP tools.
     * 
     * @see GherkinGenerator#switchToThirdPerson
     */
    private IndexedWord identifySubject(CoreSentence sentence) throws TokenNotFoundException {
        // Identify the subject of the sentence, which must be the “want” from the
        // “I want” expression of the user story.
        IndexedWord verb = identifyVerb(sentence, false);

        // Check all words that are a child of the verb in the dependency graph
        for (IndexedWord child : sentence.dependencyParse().getChildList(verb)) {
            // The subject must be linked from the verb using the “nsubj”
            // (nominal subject) relation and must be a personal pronoun (PRP)
            // and must be “I”.
            if (sentence.dependencyParse().getEdge(verb, child).getRelation().getShortName().equals("nsubj") && child.tag().equals("PRP") && child.word().equalsIgnoreCase("I")) {
                return child;
            }
        }
        // If no such word exists, we cannot continue. Throw an appropriate
        // exception.
        throw new TokenNotFoundException("The subject of the user story could not be identified.");
    }

    /**
     * Identifies the subject of the sentence, which must be the “want” from
     * the “I want” expression of the user story.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param isThirdPerson whether the expected verb is in first (“want”) or
     * third (“wants”) person
     * @return the verb of the sentence
     * @throws TokenNotFoundException if the verb could not be identified by
     * the Stanford CoreNLP tools.
     * 
     * @see GherkinGenerator#identifySubject
     * @see GherkinGenerator#postProcessingOfResultString
     */
    private IndexedWord identifyVerb(CoreSentence sentence, boolean isThirdPerson) throws TokenNotFoundException {

        // We expect the verb to either be “want”, a non-third person singular
        // present verb (VBP), or “wants”, a third person singular present verb
        // (VBZ)
        String expectedVerb = isThirdPerson ? heSheItDasSMussMit("want") : "want";
        String expectedTag = isThirdPerson ? "VBZ" : "VBP";

        // In many cases, the root object of the dependency graph itself is the
        // verb we are looking for
        IndexedWord root = sentence.dependencyParse().getFirstRoot();
        if (root.word().equalsIgnoreCase(expectedVerb) && root.tag().equals(expectedTag)) {
            return root;
        }

        // If not, it is a child of the root object (as any word in the graph
        // is). First, we look for a word with the appropriate POS tag.
        List<IndexedWord> possibleVerbs = sentence.dependencyParse().getAllNodesByPartOfSpeechPattern(expectedTag);

        // Then, we analyze the contents
        possibleVerbs.removeIf(possibleVerb -> (!possibleVerb.word().equalsIgnoreCase(expectedVerb)));

        if (possibleVerbs.size() == 0) {
            // If there is no matching word, we cannot continue. Throw an
            // appropriate exception.
            throw new TokenNotFoundException("The verb of the user story could not be identified.");
        }

        // There might be multiple children of the root whose POS tag and
        // content match what we looking for. We sort them by their distance
        // to the root object in the graph and return the shallowest word.
        possibleVerbs.sort((possibleVerb, otherPossibleVerb) -> (sentence.dependencyParse().getPathToRoot(possibleVerb).size() - sentence.dependencyParse().getPathToRoot(otherPossibleVerb).size()));
        return possibleVerbs.get(0);
    }

    /**
     * Finds all coreferences of a word, i.e., allwords (e.g. pronouns) that
     * refer to the same entity as the given word.
     * 
     * @param document a {@code CoreDocument} containing the NLP analysis
     * result of the user story
     * @param word the word of which coreferences are to be found
     * @return a list of words which are coreferences of the word we analyze
     * 
     * @see GherkinGenerator#switchToThirdPerson
     */
    private List<IndexedWord> getCoreferencesOfWord(CoreDocument document, IndexedWord word) {
        // We iterate through all coreference chains that have been detected
        for (CorefChain chain : document.annotation().get(CorefCoreAnnotations.CorefChainAnnotation.class).values()) {
            // In the current chain, we check whether it includes our word
            Set<CorefMention> mentionsWithWordAsHead = chain.getMentionsWithSameHead(1, word.index());
            if (mentionsWithWordAsHead != null) {
                // If there are coreferences of our word, we extract their
                // first word and return them. Since we are only interested
                // in (one-word) pronouns, we do not need to care about other
                // words being part of the mentions. 
                List<CorefMention> allMentionsOfWord = chain.getMentionsInTextualOrder();
                List<IndexedWord> coreferencesOfWord = new ArrayList<IndexedWord>();
                for (CorefMention mentionOfWord : allMentionsOfWord) {
                    coreferencesOfWord.add(document.sentences().get(0).dependencyParse().getNodeByIndex(mentionOfWord.headIndex));
                }
                return coreferencesOfWord;
            }
        }
        // If no coreferences are found, return an empty list.
        return new ArrayList<IndexedWord>();
    }

    /**
     * Adds a third-person s to the verb of a subject.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param subject the subject whose verbs are to be modified
     * @return a map which shows where to replace which words by which other
     * words in order to add the third-person s to the verb of the subject.
     * 
     * @see GherkinGenerator#switchToThirdPerson
     */
    private Map<Integer, String> addSToVerbOfSubject(CoreSentence sentence, IndexedWord subject) {
        Map<Integer, String> newReplacements = new HashMap<Integer, String>();

        // In many cases, the verb of the subject is its parent
        IndexedWord parent = sentence.dependencyParse().getParent(sentence.dependencyParse().getNodeByIndex(subject.index()));
        if (parent.tag().equals("VBP")) {
            // If the parent is indeed a third-person single present verb
            newReplacements.put(parent.index(), heSheItDasSMussMit(parent.word()));
        } else if (parent.tag().equals("JJ") || parent.tag().startsWith("NN")) {
            // If the parent is an adjective or a noun or proper noun, we check
            // the children of the parent for third-person single present verbs
            // which are related to the parent by a copular relation.
            IndexedWord child = getFirstChildWithRelationAndTag(sentence.dependencyParse(), parent, "cop", "VBP");
            if (child != null) {
                newReplacements.put(child.index(), heSheItDasSMussMit(child.word()));
            }
        } else if (parent.tag().equals("VB") || parent.tag().equals("VBN")) {
            // If the parent is a base-form verb or a past-participle verb, we
            // check the children of the parent for third-person single present
            // verbs which are related to the parent by an auxiliary relation.
            IndexedWord child = getFirstChildWithRelationAndTag(sentence.dependencyParse(), parent, "aux", "VBP");
            if (child != null) {
                newReplacements.put(child.index(), heSheItDasSMussMit(child.word()));
            }
        }
        return newReplacements;
    }

    /**
     * Replaces words in a sentence string by other words.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param string the sentence string
     * @param replacements a map which shows where to replace which words by
     * which other words
     * @return the updated sentence string
     * 
     * @see GherkinGenerator#preprocessing
     */
    private String replaceWordsInSentence(CoreSentence sentence, String string, Map<Integer, String> replacements) {
        List<Integer> indicesOfWordsToBeReplaced = new ArrayList<Integer>(replacements.keySet());
        String updatedString = string;

        // Iterate through the map entries in reverse order, so that previous
        // replacements do not affect the positions of later replacements in
        // the string.
        indicesOfWordsToBeReplaced.sort(Comparator.reverseOrder());
        for (int indexOfWordsToBeReplaced : indicesOfWordsToBeReplaced) {
            // Get the begin and end positions for the replacement from the
            // dependency graph nodes
            int startIndexInString = sentence.dependencyParse().getNodeByIndex(indexOfWordsToBeReplaced).beginPosition();
            int endIndexInString = sentence.dependencyParse().getNodeByIndex(indexOfWordsToBeReplaced).endPosition();

            // Cut the string at the begin and end position and replace the
            // middle part by the corresponding replacement string from the map
            updatedString = updatedString.substring(0, startIndexInString) + replacements.get(indexOfWordsToBeReplaced) + updatedString.substring(endIndexInString);
        }
        return updatedString;
    }

    /**
     * Adds a third-person s to a given verb and handles irregular verbs.
     * 
     * @param verb the verb to be converted to third person
     * @return the verb in third person
     * 
     * @see GherkinGenerator#addSToVerbOfSubject
     * @see GherkinGenerator#identifyVerb
     * @see GherkinGenerator#postProcessingOfResultString
     * @see <a href="https://www.gymglish.com/en/gymglish/english-grammar/the-s-in-the-third-person-singular-form">https://www.gymglish.com/en/gymglish/english-grammar/the-s-in-the-third-person-singular-form</a>
     * for the rules implemented in this method
     */
    private String heSheItDasSMussMit(String verb) {
        // Irregular verbs are handled manually
        if (verb.equals("am") || verb.equals("be")) {
            return "is";
        } else if (verb.equals("have")) {
            return "has";
        } else if (verb.equals("do")) {
            return "does";
        } else if (verb.equals("go")) {
            return "goes";
        }

        // Verbs which end with a certain ending require “-es” to be appended
        if (verb.toLowerCase().endsWith("x") || verb.toLowerCase().endsWith("ss") || verb.toLowerCase().endsWith("ch") || verb.toLowerCase().endsWith("sh")) {
            return verb + "es";
        }
        
        // Verbs which end with “y” and a vowel before the “y” require “ies” to
        // be appended to the verb excluding the “y”
        if (verb.toLowerCase().endsWith("y") && !Arrays.asList('a', 'e', 'i', 'o', 'u').contains(verb.charAt(verb.length() - 2))) {
            return verb.substring(0, verb.length() - 1) + "ies";
        }

        // In all other cases, simply append “s”
        return verb + "s";
    }

    /**
     * Extracts information regarding the role of a user story and creates an
     * acceptance criterion from it.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @return a list containing zero or one acceptance criteria with
     * information regarding the role of the user story
     * 
     * @see GherkinGenerator#generate
     */
    private List<AcceptanceCriterion> extractRolePrecondition(CoreSentence sentence, String userStoryString) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();

        // all words in the sentence
        Set<IndexedWord> wordsInUserStorySentence = sentence.dependencyParse().getSubgraphVertices(sentence.dependencyParse().getFirstRoot());
        
        // Identify the “As a” and “I want” parts of the user story, where the
        // “I want” part should be “the user wants” by now, and find the
        // 1-based indices of both keywords.
        int indexAs = Integer.MAX_VALUE;
        int indexTheUserWants = 0;
        for (IndexedWord word : wordsInUserStorySentence) {
            if (word.word().equalsIgnoreCase("as") && word.tag().equals("IN")) {
                // Also check whether “as” is a preposition and…
                indexAs = Math.min(indexAs, word.index());
            } else if (word.word().equalsIgnoreCase("the") && word.tag().equals("DT")) {
                // …“the” is a determiner, just to make sure we found the right
                // words
                if (wordsInUserStorySentence.size() < word.index() + 2) {
                    continue;
                }

                // after the determiner “the”, we expect the words “user”, a
                // singular noun (NN), and “wants”, a third-person singular
                // present verb (VBZ)
                IndexedWord expectedUser = sentence.dependencyParse().getNodeByIndex(word.index() + 1);
                IndexedWord expectedWants = sentence.dependencyParse().getNodeByIndex(word.index() + 2);
                if (expectedUser.word().equalsIgnoreCase("user") && expectedUser.tag().equals("NN") && expectedWants.word().equalsIgnoreCase("wants") && expectedWants.tag().equals("VBZ")) {
                    indexTheUserWants = Math.max(indexTheUserWants, word.index());

                    // Since the “the user wants” must occur after the “As a”,
                    // we can stop here
                    break;
                }
            }
        }

        if (indexAs == Integer.MAX_VALUE || indexTheUserWants == 0) {
            // If one part could not be identified, we cannot continue with
            // identifying a role precondition acceptance criterion. This
            // should not happen, so we add a warning message to the acceptance
            // criteria list.
            acceptanceCriteria.add(new AcceptanceCriterion("The role of the user story could not be identified.", AcceptanceCriterionType.WARNING));
        } else {
            // If both parts were identified, we determine the 1-based indices
            // of the first word after “As a” and the last word before the “the
            // user wants”, which should correspond to the role specification
            // in the user story, and then retrieve the begin and end position
            // of these words in the user story string.
            int beginPosition = sentence.dependencyParse().getNodeByIndex(indexAs + 1).beginPosition();
            int endPosition = sentence.dependencyParse().getNodeByIndex(indexTheUserWants - 1).endPosition();

            // If the role specification ends with a comma (e.g. “As a
            // developer, the user wants…”), we exclude it.
            //          ^
            if (sentence.dependencyParse().getNodeByIndex(indexTheUserWants - 1).tag().equals(",")) {
                endPosition = sentence.dependencyParse().getNodeByIndex(indexTheUserWants - 1 - 1).endPosition();
            }
            acceptanceCriteria.add(new AcceptanceCriterion(userStoryString.substring(beginPosition, endPosition), AcceptanceCriterionType.ROLE, indexAs, indexTheUserWants - 1));
        }

        return acceptanceCriteria;
    }

    /**
     * Identifies the first child of a word in a dependency graph, which has a
     * specified POS tag and is linked to its parent word via a specified
     * relation.
     * 
     * @param graph the dependency graph
     * @param parent the word which children are examined
     * @param relationShortName the short name of the grammatical relation
     * between the word and the child
     * @param tag the POS tag the child shall have
     * @return the first child of the given word with the specified relation
     * and POS tag, or {@code null}, if none exist.
     * 
     * @see GherkinGenerator#addSToVerbOfSubject
     */
    private IndexedWord getFirstChildWithRelationAndTag(SemanticGraph graph, IndexedWord parent, String relationShortName, String tag) {
        List<IndexedWord> children = graph.getChildList(parent);
        for (IndexedWord child : children) {
            if (graph.getEdge(parent, child).getRelation().getShortName().startsWith(relationShortName) && child.tag().equals(tag)) {
                return child;
            }
        }
        return null;
    }

    /**
     * Extracts information regarding the user interface of a user story and
     * creates an acceptance criterion from it.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @return a list containing zero or one acceptance criteria with
     * information regarding the user interface of the user story
     * 
     * @see GherkinGenerator#generate
     */
    private List<AcceptanceCriterion> extractUIPrecondition(CoreSentence sentence, String userStoryString) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();
        List<String> nerTags = sentence.nerTags(); // the named entity recognizer tags
        List<String> posTags = sentence.posTags(); // the POS tags
        List<String> tokensAsStrings = sentence.tokensAsStrings(); // the words of the user story
        int beginIndex = Integer.MAX_VALUE;

        // If a user interface description is found by the Named Entity
        // Recognizer, the words being part of that description are tagged with
        // “UI”.

        // for every word in the sentence
        for (int i = 0; i < nerTags.size() - 1; i++) {
            if (nerTags.get(i).equals("UI")) {
                // We found a UI description and continue with it
                beginIndex = i;
                break;
            }
            if (tokensAsStrings.get(i).equalsIgnoreCase("so") && tokensAsStrings.get(i + 1).equalsIgnoreCase("that")) {
                // We have reached the reason part of the user story and will
                // not find any useful UI description there, so we return the
                // empty list
                return acceptanceCriteria;
            }
        }

        if (beginIndex == Integer.MAX_VALUE) {
            // We have not found a UI description in the entire user story, so
            // we return the empty list
            return acceptanceCriteria;
        }

        // We now need to find the end of the user interface description.
        int endIndex = getEndIndexOfUI(beginIndex, sentence);
        if (endIndex == 0 || endIndex == nerTags.size()) {
            // If no end has been found or the presumed end is a word after the
            // last word of the user story, the UI description ends at the last
            // word of the user story.
            endIndex = nerTags.size() - 1;
        }
        if (posTags.get(endIndex).equals(",") || posTags.get(endIndex).equals("HYPH")) {
            // If the UI description ends with a comma or a hyphen, we remove
            // this last token
            endIndex -= 1;
        }

        // If both parts were identified, we determine the 1-based indices of
        // the first and last UI description words and then retrieve the begin
        // and end position of these words in the user story string. However,
        // we make sure that the first word of the UI description is “the”
        // (which is always required to be part of a UI description by the NER
        // regex) and not “displayed”, which may also occur.
        int beginPosition = sentence.dependencyParse().getNodeByIndex(beginIndex + 1).beginPosition();
        beginPosition = userStoryString.indexOf("the", beginPosition);
        int endPosition = sentence.dependencyParse().getNodeByIndex(endIndex + 1).endPosition();
        acceptanceCriteria.add(new AcceptanceCriterion(userStoryString.substring(beginPosition, endPosition), AcceptanceCriterionType.UI, beginIndex + 1, endIndex + 1));

        return acceptanceCriteria;
    }

    /**
     * Determines the 0-based index of the last word of a UI description.
     * 
     * @param beginIndex the 0-based index of the first word of a UI
     * description
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the 0-based index of the last word of the UI description
     * 
     * @see GherkinGenerator#extractUIPrecondition
     */
    private int getEndIndexOfUI(int beginIndex, CoreSentence sentence) {
        List<String> nerTags = sentence.nerTags(); // the named entity recognizer tags
        List<String> posTags = sentence.posTags(); // the POS tags
        List<String> tokensAsStrings = sentence.tokensAsStrings(); // the words of the user story
        int endIndex = 0;

        // for every word in the sentence, beginning with the first word of the
        // UI description
        for (int i = beginIndex; i < nerTags.size(); i++) {
            if (i < endIndex) {
                // if we already found out that the end of the UI description
                // lays beyond the current word
                continue;
            }
            if (!nerTags.get(i).equals("UI") && !posTags.get(i).startsWith("NN") && !posTags.get(i).equals(",") && !posTags.get(i).equals("HYPH")) {
                // If the NER tag of the current word is not “UI” and the
                // current word is not a noun or proper noun, and the current
                // word is not a comma or a hyphen, we may have reached the end
                // of the user story description. However, there are a few 
                // exceptions which are to be checked now.
                endIndex = i - 1;
                List<String> prepositions = Arrays.asList("under", "of", "for");
                if (prepositions.contains(tokensAsStrings.get(i).toLowerCase()) && sentence.dependencyParse().getParent(sentence.dependencyParse().getNodeByIndex(i + 1)).tag().startsWith("NN")) {
                    // If the current word is one of the above prepositions and
                    // its parent in the dependency graph (i + 1 because of the
                    // 1-based index in the graph) is a noun or proper noun,
                    // we have not reached the end of the user story
                    // description. The noun or proper noun (e.g. “EVENT” in
                    // the expression “the event details of an EVENT”) is part
                    // of the user story, so its 0-based index is the smallest
                    // possible value for the end index.
                    if (tokensAsStrings.get(i).equals("for") && posTags.get(i + 1).equals("VBG")) {
                        // However, if the preposition is “for” and the
                        // following verb is a gerund or a present participle
                        // verb as in “I want to have an icon in the
                        // registrations view FOR importing registrations”, we
                        // have not not reached (i.e., we have indeed reached)
                        // the end of the UI description.
                        break;
                    }
                    endIndex = sentence.dependencyParse().getParent(sentence.dependencyParse().getNodeByIndex(i + 1)).index() - 1;
                } else if (tokensAsStrings.get(i).equals("in") && (nerTags.get(i + 1).equals("UI") || tokensAsStrings.get(i + 2).equalsIgnoreCase("list") || tokensAsStrings.get(i + 1).equalsIgnoreCase("CoMET"))) {
                    // If the current word is “in” followed by another UI
                    // description, as in “in the event cockpit IN the event
                    // details” or followed by a specific list, as in “in the
                    // event cockpit IN the LIST of participants” or followed
                    // by “CoMET”, as in “in the event cockpit in CoMET”, we
                    // have not reached the end of the UI description since the
                    // aforementioned words following “in” are part of the UI
                    // description.
                    endIndex = i + 2;
                } else if (posTags.get(i).equals("``") && posTags.subList(i + 1, posTags.size()).contains("''")) {
                    // If the current token are opening quotation marks and the
                    // user story sentence contains closing quotation marks
                    // after it, we have not reached the end of the UI
                    // description since the content of the quotation marks is
                    // part of the UI description, as in “the view "List
                    // Registrations"”.
                    endIndex = i + 2 + posTags.subList(i + 1, posTags.size()).indexOf("''");
                } else if (posTags.get(i).equals("-LRB-") && posTags.get(i + 2).equals("-RRB-") && tokensAsStrings.get(i + 1).equals("ET")) {
                    // If the current token is an opening parenthesis, the next
                    // token is “ET” and the following token is a closing
                    // parenthesis, we have not reached the end of the UI
                    // description since “(ET)” describes the UI selection
                    // “event type Developer Days (ET)” and is part of the UI
                    // description.
                    endIndex = i + 3;
                } else if (tokensAsStrings.get(i).equals("\"") && tokensAsStrings.subList(i + 1, tokensAsStrings.size()).contains("\"")) {
                    // If the current token are quotation marks and the user
                    // story sentence contains another quotation mark token
                    // after it, we have not reached the end of the UI
                    // description since the content of the quotation marks is
                    // part of the UI description, as in “the view "List
                    // Registrations"”.
                    endIndex = i + 2 + tokensAsStrings.subList(i + 1, tokensAsStrings.size()).indexOf("\"");
                } else if (tokensAsStrings.get(i).equals(">") && (posTags.get(i - 1).equals("HYPH") || tokensAsStrings.get(i - 1).equals("-"))) {
                    // If the current token is “>” and the previous token is a
                    // hyphen, we have not reached the end of the UI
                    // description, since the arrow “->” points to another UI
                    // description, as in “in the DSBC under Contacts -> List
                    // Contacts”. 
                    endIndex = i + 1;
                } else {
                    // If none of the exceptions occured, we are indeed at the
                    // end of the UI description.
                    break;
                }
            }
        }
        return endIndex;
    }

    /**
     * Extracts actions from a user story and creates acceptance criteria from
     * it.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @return a list containing zero or more acceptance criteria with
     * actions from the user story
     * 
     * @see GherkinGenerator#generate
     */
    private List<AcceptanceCriterion> extractActions(CoreSentence sentence, String userStoryString) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();
        List<String> tokensAsStrings = sentence.tokensAsStrings();

        // Find the 1-based index of the “so that” keyword of the user story
        // or the 1-based index of the last word, if there is no reason in the
        // user story.
        int indexSoThat = tokensAsStrings.size() + 1;
        for (int i = 1; i < tokensAsStrings.size(); i++) {
            if (tokensAsStrings.get(i - 1).equalsIgnoreCase("so") && tokensAsStrings.get(i).equalsIgnoreCase("that")) {
                indexSoThat = i;
                break;
            }
        }

        // These words weaken a conditional sentence. For example, if a user
        // story goes “I want B to happen if A occurs”, A is the only known
        // cause for the effect B. However, if the user story goes “I want B to
        // happen even if A occurs”, there appear to be many other causes for
        // B. We are not interested in those conditions.
        List<String> conditionalLimiterStrings = Arrays.asList("also", "even", "especially", "necessary");

        List<IndexedWord> conditionalStarterWords = new ArrayList<IndexedWord>();

        // Look for conditional starter words (declared above) in the words of
        // the user story that are before the user story reason.
        for (int i = 3; i < indexSoThat; i++) {
            IndexedWord word = sentence.dependencyParse().getNodeByIndex(i);
            if ((conditionalStarterStrings.contains(word.word().toLowerCase()) || isAsSoonAs(sentence, i)) && !conditionalLimiterStrings.contains(sentence.dependencyParse().getNodeByIndex(i - 1).word().toLowerCase()) && !sentence.dependencyParse().getNodeByIndex(i + 1).word().equalsIgnoreCase("and")) {
                // If the current word is either a conditional starter word or
                // the AS in an “as soon AS” and the previous word is not a
                // conditional limiter word and the following word is not “and”
                // (to exclude structures like “I want to know when AND from
                // which IP adress …”), we have found a conditional sentence.
                conditionalStarterWords.add(sentence.dependencyParse().getNodeByIndex(i));
            }
        }

        if (indexSoThat + 2 < tokensAsStrings.size() && conditionalStarterStrings.contains(sentence.dependencyParse().getNodeByIndex(indexSoThat + 2).word().toLowerCase())) {
            // If the word following “so that” is a conditional starter word,
            // the reason of the user story is an example containing a
            // conditional sentence which we can use (e.g. “…, so that if A
            // occurs, B happens.”).
            conditionalStarterWords.add(sentence.dependencyParse().getNodeByIndex(indexSoThat + 2));
        }

        // Extract an action from every conditional starter word
        for (IndexedWord conditionalStarterWord : conditionalStarterWords) {
            acceptanceCriteria.addAll(extractActionFromConditionalStarterWord(sentence, userStoryString, conditionalStarterWord, indexSoThat));
        }

        // Also look for interactions in the user story, as in “I want to click
        // A in order to reach B”, and extract actions from them.
        acceptanceCriteria.addAll(extractActionFromInteraction(sentence, userStoryString));

        return acceptanceCriteria;
    }

    /**
     * Checks whether the expression “as soon as” is present at the specified
     * position in the given sentence. The 1-based index must point at the
     * second “as”.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param i the 1-based index to check
     * @return {@code true} if “as soon as” is present at the specified
     * position
     * 
     * @see GherkinGenerator#extractActions
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private boolean isAsSoonAs(CoreSentence sentence, int i) {
        return sentence.dependencyParse().getNodeByIndex(i).word().equalsIgnoreCase("as") && sentence.dependencyParse().getNodeByIndex(i - 1).word().equalsIgnoreCase("soon") && sentence.dependencyParse().getNodeByIndex(i - 2).word().equalsIgnoreCase("as");
    }

    /**
     * Extracts an action that begins at a conditional starter word.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @param conditionalStarterWord the conditional starter word with which
     * the action begins
     * @param indexSoThat the 1-based index of the “so that” keyword of the
     * user story or the 1-based index of the last word, if there is no reason
     * in the user story.
     * @return a list containing zero or one acceptance criteria with an action
     * from the user story and optionally an acceptance criterion with an
     * expected result, if the action is part of the reason of the user story
     * 
     * @see GherkinGenerator#extractActions
     */
    private List<AcceptanceCriterion> extractActionFromConditionalStarterWord(CoreSentence sentence, String userStoryString, IndexedWord conditionalStarterWord, int indexSoThat) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();

        // Get the root of the conditional sentence, whose subgraph in many
        // cases contains exactly the words of the conditional sentence, and
        // extract those words.
        IndexedWord root = getRootOfAction(sentence, conditionalStarterWord);
        List<IndexedWord> actionWords = new ArrayList<IndexedWord>();
        actionWords.addAll(sentence.dependencyParse().getSubgraphVertices(root));

        if (actionWords.size() < 2) {
            // If we are unable to find more words being part of the
            // conditional sentence, we cannot continue and return the empty
            // list.
            return acceptanceCriteria;
        }

        // We need to sort the list of action words since “getSubgraphVertices”
        // returns a set, not a list.
        actionWords.sort((word, otherWord) -> word.index() - otherWord.index());

        // Words that come before the conditional starter word cannot be part
        // of the conditional sentence.
        actionWords.removeIf(word -> word.index() < conditionalStarterWord.index());

        // Since the words to be extracted will be prepended with WHEN, we do
        // not need to extract the conditional starter word itself.
        int beginIndex = conditionalStarterWord.index() + 1;

        // However, if the conditional sentence is prepended by a duration
        // (which is recognized by the Named Entity Recognizer) such as “I want
        // B to happen three months after A”, the duration shall be part of the
        // extracted words.
        if (sentence.nerTags().get(conditionalStarterWord.index() - 1 - 1).equals("DURATION")) {
            beginIndex = getBeginIndexOfDuration(conditionalStarterWord, sentence);
        }

        // We need to determine the index of the last word that still is part
        // of the conditional sentence.
        int endIndex = determineActionEndIndex(actionWords, conditionalStarterWord, indexSoThat, sentence);

        int wordsInSentenceCount = sentence.dependencyParse().getSubgraphVertices(sentence.dependencyParse().getFirstRoot()).size();
        if (conditionalStarterWord.index() > indexSoThat && endIndex >= wordsInSentenceCount - 1) {
            // If the conditional sentence is part of the reason of the user
            // story and includes all words up to the last word in the user
            // story, we do not have words which may create an expected result
            // to this action, so we cannot continue and return the empty list.
            return acceptanceCriteria;
        }

        // We determine the 1-based indices of the first and last action words
        // and then retrieve the begin and end position of these words in the
        // user story string. 
        int beginPosition = sentence.dependencyParse().getNodeByIndex(beginIndex).beginPosition();
        int endPosition = sentence.dependencyParse().getNodeByIndex(endIndex).endPosition();
        String actionString = userStoryString.substring(beginPosition, endPosition);

        if (sentence.nerTags().get(conditionalStarterWord.index() - 1 - 1).equals("DURATION")) {
            // If the conditional sentence is prepended by a duration as
            // described above, the exemplary sentence “I want B to happen
            // three months after A” is rearranged to “[WHEN] three months
            // passed after A”
            actionString = userStoryString.substring(beginPosition, conditionalStarterWord.beginPosition()) + "passed " + userStoryString.substring(conditionalStarterWord.beginPosition(), endPosition);
        } else if (isAsSoonAs(sentence, beginIndex - 1)) {
            // If the conditional sentence starts with “as soon as”, the begin
            // index shall point to the first “as”, so that it is clear that
            // this acceptance criterion also includes the words “as soon as”,
            // which must not be part of any expected result.
            beginIndex -= 3;
        } else {
            // If the conditional sentence starts with another conditional
            // starter word, the begin index shall point at it, so that it is
            // clear that this acceptance criterion also includes this
            // conditional starter word, which must not be part of any expected
            // result.
            beginIndex -= 1;
        }
        if (!verbInAction(actionWords, root, actionString)) {
            // If there is no verb in the action, we most likely have a
            // temporal relation like “after the import”, where we need to add
            // a verb in order to create an action acceptance criteria, as in
            // “[WHEN] the import HAPPENS”
            actionString += " happens";
        }
        if (conditionalStarterWord.index() < indexSoThat) {
            // If the action is located in the goal of the user story, we
            // simply add it to the list.
            acceptanceCriteria.add(new AcceptanceCriterion(actionString, AcceptanceCriterionType.ACTION, beginIndex, endIndex));
        } else {
            // If the action is located in the reason of the user story, we
            // assign the corresponding _IN_REASON type to it and also generate
            // an expected result from the remainder of the reason, which we
            // add to the list of acceptance criteria.
            acceptanceCriteria.add(new AcceptanceCriterion(actionString, AcceptanceCriterionType.ACTION_IN_REASON, beginIndex, endIndex));
            acceptanceCriteria.addAll(extractResultInformationInReason(sentence, userStoryString, endIndex));
        }
        return acceptanceCriteria;
    }

    /**
     * Determines the 1-based index of the first word of a duration identified
     * by the Named Entity Recognizer.
     * 
     * @param conditionalStarterWord the word succeeding the duration
     * expression
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the 1-based index of the first word of the duration
     * 
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private int getBeginIndexOfDuration(IndexedWord conditionalStarterWord, CoreSentence sentence) {
        // Remember that the indices of the nerTags() list are 0-based
        int indexOfDuration = conditionalStarterWord.index() - 1 - 1;
        while (sentence.nerTags().get(indexOfDuration - 1).equals("DURATION")) {
            indexOfDuration -= 1;
        }
        return indexOfDuration + 1;
    }


    /**
     * Determines the (presumed) existence of a verb among a set of words.
     * 
     * @param actionWords the set of words to investigate
     * @param root the root of a dependency graph subgraph
     * @param actionString the string containing an action acceptance criterion
     * @return {@code true} if a verb exists among the set of words or evidence
     * suggests that a verb has been cut off or has falsely been detected as a
     * plural noun
     * 
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private boolean verbInAction(List<IndexedWord> actionWords, IndexedWord root, String actionString) {
        for (IndexedWord actionWord : actionWords) {
            if (actionWord.tag().startsWith("VB")) {
                return true;
            }
        }
        // If the action string ends with “[…]”, it is likely that the user
        // story was cut off at that location and there used to be a verb in
        // the action. Also, if the root word of the conditional sentence is
        // detected as a plural noun (NN[P]S), it is likely that the root is
        // actually a verb that has been falsely detected as a plural noun.
        return actionString.endsWith("[…]") || (root.tag().startsWith("NN") && root.tag().endsWith("S"));
    }

    /**
     * Determines the 1-based index of the last word of an action.
     * 
     * @param wordsInAction the list of words of the action
     * @param conditionalStarterWord the conditional starter word of the action
     * @param indexSoThat the 1-based index of the “so that” keyword of the
     * user story
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the 1-based index of the last word of the action
     * 
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private int determineActionEndIndex(List<IndexedWord> wordsInAction, IndexedWord conditionalStarterWord, int indexSoThat, CoreSentence sentence) {
        // We assume that all words in the list are actually part of the action
        int endIndex = wordsInAction.get(wordsInAction.size() - 1).index();
        if (conditionalStarterWord.index() < indexSoThat) {
            // If the “so that” keyword of the user story interrupts the action
            // words, the action ends there.
            endIndex = Math.min(endIndex, indexSoThat - 1);
        }

        // We iterate through the words and count the number of parentheses we
        // are currently in.
        int inParentheses = 0;
        for (IndexedWord wordInAction : wordsInAction) {
            if (wordInAction.tag().equals("-LRB-")) {
                // left parenthesis
                inParentheses += 1;
            } else if (wordInAction.tag().equals("-RRB-")) {
                // right parenthesis
                inParentheses -= 1;
            } else if ((wordInAction.word().equals(",") || (wordInAction.word().equalsIgnoreCase("that") && wordInAction.tag().equals("IN"))) && inParentheses == 0) {
                // If we reached a comma or a “that” preposition, it is likely
                // that we reached the end of the action. However, commas
                // inside parentheses often result from enumerations and do not
                // end the action.
                endIndex = Math.min(endIndex, wordInAction.index() - 1);
                break;
            }
        }
        
        // If an opening parenthesis follows the action, it is likely that it
        // belongs to the action. Therefore, we add the content of the
        // parenthesis to the action.
        if (endIndex < sentence.posTags().size() && sentence.posTags().get(endIndex - 1 + 1).equals("-LRB-")) {
            endIndex += 1;
            inParentheses += 1;
        }
        while (endIndex < sentence.posTags().size() && inParentheses > 0) {
            endIndex += 1;
            if (sentence.posTags().get(endIndex - 1).equals("-RRB-")) {
                // Here, we found the closing parenthesis.
                inParentheses -= 1;
            }
        }
        return endIndex;
    }

    /**
     * Extracts an expected result acceptance criterion from the reason of a
     * user story.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @param endIndexOfAction the 1-based index of the last word of the
     * preceeding action
     * @return a list of zero or one expected result acceptance criteria
     * 
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private List<AcceptanceCriterion> extractResultInformationInReason(CoreSentence sentence, String userStoryString, int endIndexOfAction) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();
        int wordsInSentenceCount = sentence.dependencyParse().getSubgraphVertices(sentence.dependencyParse().getFirstRoot()).size();
        
        // the expected result begins where the action ended
        int beginIndex = endIndexOfAction + 1;
        
        // the expected result contains all words after the action
        int endIndex = wordsInSentenceCount;

        if (sentence.dependencyParse().getNodeByIndex(beginIndex).word().equals(",")) {
            // if the action ended at a comma, that comma is not part of the
            // expected result
            beginIndex += 1;
        }
        if (sentence.dependencyParse().getNodeByIndex(endIndex).tag().equals(".")) {
            // the sentence period is not part of the expected result
            endIndex -= 1;
        }

        if (beginIndex <= endIndex) {
            // If there are words left after the end of the action, we
            // determine the 1-based indices of the first and last words and
            // then retrieve the begin and end position of these words in the
            // user story string. 
            int beginPosition = sentence.dependencyParse().getNodeByIndex(beginIndex).beginPosition();
            int endPosition = sentence.dependencyParse().getNodeByIndex(endIndex).endPosition();
            acceptanceCriteria.add(new AcceptanceCriterion(userStoryString.substring(beginPosition, endPosition), AcceptanceCriterionType.RESULT_IN_REASON, endIndexOfAction + 1, wordsInSentenceCount));
        }
        return acceptanceCriteria;
    }

    /**
     * Extracts an interaction from a user story and creates an action
     * acceptance criteria from it.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @return a list containing zero or one acceptance criteria with
     * actions from an interaction in the user story
     * 
     * @see GherkinGenerator#extractActions
     */
    private List<AcceptanceCriterion> extractActionFromInteraction(CoreSentence sentence, String userStoryString) {
        List<AcceptanceCriterion> acceptanceCriteria = new ArrayList<AcceptanceCriterion>();
        if (!userStoryString.toLowerCase().contains("to click")) {
            // If there is no interaction in the specified form, we cannot
            // continue and return the empty list.
            return acceptanceCriteria;
        }

        // Determine the start position of the interaction as the position of
        // the first character after the “to click” expression and a space.
        int beginPosition = userStoryString.toLowerCase().indexOf("to click") + "to click ".length();

        // The interaction ends in most cases after one of the words “to” or
        // “and”, the position of which we are determining next.
        int endPositionTo = userStoryString.toLowerCase().indexOf(" to ", beginPosition);
        int endPositionAnd = userStoryString.toLowerCase().indexOf(" and ", beginPosition);
        int endPosition = -1;
        if (endPositionTo == -1 ^ endPositionAnd == -1) {
            // If exactly one of the words was found, its position is larger
            // than the other position (which is -1), so we use the maximum of
            // both values
            endPosition = Math.max(endPositionTo, endPositionAnd);
        } else {
            // If both or no words were found, we use the minimum to make use
            // of the first word (if no words are found, both positions are -1)
            endPosition = Math.min(endPositionTo, endPositionAnd);
        }

        // If we found the end of the interaction
        if (endPosition != -1) {
            String acceptanceCriterionString = userStoryString.substring(beginPosition, endPosition);
            // In order to be able to remove the interaction information from
            // the expected result, we need to know the 1-based indices of the
            // first and last words that are included in the action acceptance
            // criterion.
            int beginIndex = getIndexFromPosition(sentence, beginPosition - "click ".length(), true);
            int endIndex = getIndexFromPosition(sentence, endPosition + " and".length(), false);

            // Remove commas and spaces from the end of the action
            while (acceptanceCriterionString.endsWith(",") || acceptanceCriterionString.endsWith(" ")) {
                acceptanceCriterionString = acceptanceCriterionString.substring(0, acceptanceCriterionString.length() - 1);
            }

            // The interaction “I want to be able to click on the button and
            // receive results” would be restructured into “WHEN the user
            // clicks on the button”.
            acceptanceCriteria.add(new AcceptanceCriterion("the user clicks " + acceptanceCriterionString, AcceptanceCriterionType.ACTION, beginIndex, endIndex));
        }
        return acceptanceCriteria;
    }

    /**
     * Determines the 1-based index of a word whose begin or end position is
     * identical to the position specified.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param position the begin or end position of a word in the user story
     * string
     * @param isBeginPosition whether the begin or end position is specified
     * @return the 1-based index of the word whose position is identical to the
     * position specified
     * 
     * @see GherkinGenerator#extractActionFromInteraction
     */
    private int getIndexFromPosition(CoreSentence sentence, int position, boolean isBeginPosition) {
        Set<IndexedWord> wordsInSentence = sentence.dependencyParse().getSubgraphVertices(sentence.dependencyParse().getFirstRoot());
        int beginIndex = Integer.MAX_VALUE;
        int endIndex = 0;

        // Iterate over every word in the dependency graph
        for (IndexedWord word : wordsInSentence) {
            if (word.beginPosition() >= position) {
                // If the current word’s begin position is not before the
                // specified position and is also the first word with that
                // property, we remember its 1-based index.
                beginIndex = Math.min(beginIndex, word.index());
            }
            if (word.endPosition() <= position) {
                // If the current word’s end position is not after the
                // specified position and is also the last word with that
                // property, we remember its 1-based index.
                endIndex = Math.max(endIndex, word.index());
            }
        }

        // Return the index that was asked for
        return isBeginPosition ? beginIndex : endIndex;
    }

    /**
     * Determines the root node of a dependency graph subgraph which is likely
     * to contain all words of an action
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param conditionalStarterWord the conditional starter word of the action
     * @return the root node of a dependency graph subgraph which is likely to
     * contain all words of the action
     * 
     * @see GherkinGenerator#extractActionFromConditionalStarterWord
     */
    private IndexedWord getRootOfAction(CoreSentence sentence, IndexedWord conditionalStarterWord) {
        IndexedWord parent = sentence.dependencyParse().getParent(conditionalStarterWord);
        if (parent.tag().startsWith("VB") && parent.index() > conditionalStarterWord.index()) {
            // If the parent of the conditional starter word is a verb which
            // lies after the conditional starter word, it is most likely the
            // root element we are looking for.
            return parent;
        }
        if (sentence.dependencyParse().getSubgraphVertices(conditionalStarterWord).size() > 1 || sentence.dependencyParse().getNodeByIndex(conditionalStarterWord.index() + 1).word().equalsIgnoreCase("necessary") || sentence.dependencyParse().getNodeByIndex(conditionalStarterWord.index() - 1).tag().equals("-LRB-") || sentence.nerTags().get(conditionalStarterWord.index() - 1).toUpperCase().startsWith("DATE")) {
            // If the conditional starter word’s subgraph itself contains more
            // than one element, it is our best guess for the root element of
            // the action word subgraph. Otherwise, our best guess is the
            // parent element, unless evidence suggests that the conditional
            // starter word does not start a conditional sentence which should
            // be converted into an action acceptance criterion at all. This is
            // the case if the conditional starter word (most likely “if”) is
            // followed by the word “necessary”, since “WHEN necessary” would
            // not be a very useful acceptance criterion. It is also the case
            // if the conditional starter word is preceeded by a parenthesis,
            // since usually those contain very short conditional sentences
            // such as “(if available)” or “(if not determinable)”. It is also
            // the case if the conditional starter word is part of a date
            // specification, as in “once a day”. In these cases, the
            // conditional starter word is returned as the root of a subgraph
            // which contains only one element, which will lead to no
            // acceptance criteria being created, as intended.
            return conditionalStarterWord;
        }
        return parent;
    }

    /**
     * Extracts the expected result from a user story and creates an acceptance
     * criterion from it. This acceptance criterion consists of all information
     * from the goal part of the user story except for the information that is
     * already included in other acceptance criteria
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @param userStoryString a string containing the user story
     * @param acceptanceCriteria all acceptance criteria extracted so far,
     * i.e., role and UI preconditions, actions and expected results from the
     * reason of the user story
     * @return a list containing one acceptance criterion with the expected
     * result of the user story
     * @throws TokenNotFoundException if the verb of the user story could not
     * be identified by the Stanford CoreNLP tools during postprocessing.
     * 
     * @see GherkinGenerator#postProcessingOfResultString
     */
    private List<AcceptanceCriterion> extractResults(CoreSentence sentence, String userStoryString, List<AcceptanceCriterion> acceptanceCriteria) throws TokenNotFoundException {
        String resultString = userStoryString;

        // Cut off the result string at the reason part of the user story
        int indexSoThat = userStoryString.toUpperCase().indexOf("SO THAT");
        if (indexSoThat != -1) {
            resultString = resultString.substring(0, indexSoThat);
        }

        // Remove commas, sentence periods and spaces at the end of the result
        // string
        while (resultString.endsWith(",") || resultString.endsWith(" ") || resultString.endsWith(".")) {
            resultString = resultString.substring(0, resultString.length() - 1);
        }

        // Iterate over all acceptance criteria
        for (AcceptanceCriterion acceptanceCriterion : acceptanceCriteria) {
            if (acceptanceCriterion.getBeginReplacementIndex() <= 0 || acceptanceCriterion.getEndReplacementIndex() > sentence.tokensAsStrings().size() || acceptanceCriterion.getBeginReplacementIndex() >= acceptanceCriterion.getEndReplacementIndex() || acceptanceCriterion.getType().equals(AcceptanceCriterionType.UI)) {
                // Acceptance criteria are skipped if they hold no valid
                // 1-based replacement indices (<= 0 or larger than the number
                // of words in the sentence or end index is larger than the
                // begin index) or if they contain UI information which is
                // handled separately.
                continue;
            }

            // We retrieve the begin and end position of the words to be
            // replaced in the user story string. 
            int beginReplacementPosition = sentence.dependencyParse().getNodeByIndex(acceptanceCriterion.getBeginReplacementIndex()).beginPosition();
            int endReplacementPosition = sentence.dependencyParse().getNodeByIndex(acceptanceCriterion.getEndReplacementIndex()).endPosition();
            if (beginReplacementPosition > resultString.length()) {
                // if the replacement would take place in the reason of the
                // user story which was already cut off, we can safely ignore it
                continue;
            }
            if (endReplacementPosition > resultString.length()) {
                // if the replacement would replace the end of the current
                // string, the end position is adjusted accordingly
                endReplacementPosition = resultString.length();
            }

            // Replace all characters between the begin and end position with
            // whitespaces, thereby retaining all other character positions for
            // future replacements.
            resultString = resultString.substring(0, beginReplacementPosition) + " ".repeat(endReplacementPosition - beginReplacementPosition) + resultString.substring(endReplacementPosition);
        }

        // Call postprocessing method before creating and returning exactly one
        // acceptance criterion.
        return Arrays.asList(new AcceptanceCriterion(postProcessingOfResultString(resultString, sentence), AcceptanceCriterionType.RESULT));
    }

    /**
     * Postprocesses the expected result string to contain only the information
     * not included in other acceptance criteria in a grammatically correct
     * context.
     * 
     * @param resultString a string containing the expected result
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the postprocessed and sanitized expected result string
     * @throws TokenNotFoundException if the verb of the user story could not
     * be identified by the Stanford CoreNLP tools
     * 
     * @see GherkinGenerator#extractResults
     */
    private String postProcessingOfResultString(String resultString, CoreSentence sentence) throws TokenNotFoundException {
        String processedResultString = resultString;

        // Identify the verb of the user story and get the following verbs
        IndexedWord verb = identifyVerb(sentence, true);
        IndexedWord firstWordAfterVerb = sentence.dependencyParse().getNodeByIndex(verb.index() + 1);
        IndexedWord secondWordAfterVerb = sentence.dependencyParse().getNodeByIndex(verb.index() + 2);
        IndexedWord thirdWordAfterVerb = sentence.dependencyParse().getNodeByIndex(verb.index() + 3);

        if (firstWordAfterVerb.tag().equals("TO") && secondWordAfterVerb.tag().equals("VB")) {
            // if the user story is in the form “the user wants to [verb]”
            // (e.g. “the user wants to be able to …”) we need to put the verb
            // after the “to” in third person and remove the “wants” (“[THEN]
            // the user is able to”)
            processedResultString = processedResultString.substring(0, verb.beginPosition()) + heSheItDasSMussMit(secondWordAfterVerb.word()) + " " + processedResultString.substring(secondWordAfterVerb.endPosition());
        } else if (firstWordAfterVerb.tag().equals("TO") && secondWordAfterVerb.tag().equals("RB") && thirdWordAfterVerb.tag().equals("VB")) {
            // if the user story is in the form “the user wants to [adverb]
            // [verb]” (e.g. “the user wants to efficiently work on …”) we need
            // to put the verb after the “adverb” in third person and remove
            // the “wants” (“[THEN] the user efficiently works on …”)
            processedResultString = processedResultString.substring(0, verb.beginPosition()) + secondWordAfterVerb.word() + " " + heSheItDasSMussMit(thirdWordAfterVerb.word()) + processedResultString.substring(thirdWordAfterVerb.endPosition());
        } else if (firstWordAfterVerb.tag().equals("IN")) {
            // if the user story is in the form “the user wants [preposition]”
            // (e.g. “the user wants that B happens”) we need to remove
            // everything before the preposition (“[THEN] B happens ”)
            processedResultString = processedResultString.substring(firstWordAfterVerb.endPosition() + 1);
        } else if (firstWordAfterVerb.tag().equals(",") && secondWordAfterVerb.tag().equals("IN")) {
            // if the user story is in the form “the user wants, [preposition]”
            // (e.g. “the user wants, that B happens”) we need to remove
            // everything before the preposition (“[THEN] B happens ”)
            processedResultString = processedResultString.substring(secondWordAfterVerb.endPosition() + 1);
        } else if (getInfinitiveToWord(sentence) != null && getInfinitiveToWord(sentence).endPosition() < processedResultString.length()) {
            IndexedWord infinitiveToWord = getInfinitiveToWord(sentence);
            if (firstWordAfterVerb.tag().equals(",") && conditionalStarterStrings.contains(secondWordAfterVerb.word().toLowerCase())) {
                // If there is an infinitive-to construction in the sentence,
                // but also a conditional starter string directly at the
                // beginning (e.g. “the user wants, when A happens, to be
                // notified”), we need to remove the comma after “wants”.
                processedResultString = processedResultString.substring(0, verb.beginPosition()) + processedResultString.substring(firstWordAfterVerb.beginPosition());
            } else {
                // If there is an infinitive-to construction in the sentence
                // (e.g. “the user wants the event information to be stored…”),
                // we need to remove everything before and including the
                // “wants”
                processedResultString = processedResultString.substring(firstWordAfterVerb.beginPosition());
            }

            // Also, we need to change the verb from its infinitive form to its
            // third person form, which means adding an “s” if the verb refers
            // to a singular noun.
            int infinitiveToIndex = processedResultString.indexOf("to " + infinitiveToWord.word());
            if (infinitiveToIndex != -1) {
                String infinitiveToString = infinitiveToWord.word();
                if (!childIsPluralNoun(verb, sentence)) {
                    // if there is no plural noun in the subgraph of the verb,
                    // we add an “s”
                    infinitiveToString = heSheItDasSMussMit(infinitiveToString);
                } else if (infinitiveToString.equalsIgnoreCase("be")) {
                    // if there is a plural noun but the verb is the irregular
                    // “to be”, we change the infinitive form to the correct
                    // form “are”
                    infinitiveToString = "are";
                }

                // We now replace the infinitive form with the third-person
                // form and also remove the “to”, resulting in the exemplary
                // results “[THEN] the user is notified” and “[THEN] the event
                // information is stored”.
                processedResultString = processedResultString.substring(0, infinitiveToIndex) + infinitiveToString + " " + processedResultString.substring(infinitiveToIndex + 3 + infinitiveToWord.word().length());
            }
        } else if (getInfinitiveToWordWithAdverb(sentence) != null && getInfinitiveToWordWithAdverb(sentence).endPosition() < processedResultString.length()) {
            IndexedWord infinitiveToWord = getInfinitiveToWordWithAdverb(sentence);
            IndexedWord adverb = sentence.dependencyParse().getNodeByIndex(infinitiveToWord.index() - 1);

            // If there is an infinitive-to construction with an adverb in the
            // sentence (e.g. “the user wants CoMET to automatically generate
            // …”), we need to remove everything before andnincluding the
            // “wants”
            processedResultString = processedResultString.substring(firstWordAfterVerb.beginPosition());

            int infinitiveToIndex = processedResultString.indexOf("to " + adverb.word() + " " + infinitiveToWord.word());
            if (infinitiveToIndex != -1) {
                String infinitiveToString = infinitiveToWord.word();
                if (!childIsPluralNoun(verb, sentence)) {
                    // if there is no plural noun in the subgraph of the verb,
                    // we add an “s”
                    infinitiveToString = heSheItDasSMussMit(infinitiveToString);
                } else if (infinitiveToString.equalsIgnoreCase("be")) {
                    // if there is a plural noun but the verb is the irregular
                    // “to be”, we change the infinitive form to the correct
                    // form “are”
                    infinitiveToString = "are";
                }
                if (adverb.word().equalsIgnoreCase("not")) {
                    // If the adverb is not, we change the order of verb and
                    // adverb: “not is” becomes “is not”
                    processedResultString = processedResultString.substring(0, infinitiveToIndex) + infinitiveToString + " " + adverb.word() + " " + processedResultString.substring(infinitiveToIndex + 4 + adverb.word().length() + infinitiveToWord.word().length());
                } else {
                    // Otherwise, we now replace the infinitive form with the
                    // third-person form and also remove the “to”, resulting in
                    // the exemplary result “[THEN] CoMET automatically
                    // generates”.
                    processedResultString = processedResultString.substring(0, infinitiveToIndex) + adverb.word() + " " + infinitiveToString + " " + processedResultString.substring(infinitiveToIndex + 4 + adverb.word().length() + infinitiveToWord.word().length());
                }
            }
        } else {
            // If none of the above cases applies, it is very likely that the
            // user story is of the form “the user wants [object]” (e.g. “the
            // user wants a button which …”). We replace the “wants” with the
            // expression “is provided with” (e.g. “[THEN] the user is provided
            // with a button which …”).
            processedResultString = processedResultString.substring(0, verb.beginPosition()) + " is provided with " + processedResultString.substring(firstWordAfterVerb.beginPosition());
        }

        // Remove leftover commas
        processedResultString = processedResultString.replaceAll(" , ", " ");

        // Replace multiple whitespaces with a single space, thereby removing
        // all the white spaces created when removing information that is part
        // of other acceptance criteria
        processedResultString = processedResultString.replaceAll("\\s+", " ");

        // Remove whitespaces at the beginning
        processedResultString = processedResultString.replaceAll("^\\s+", "");

        // Remove whitespaces, commas and sentence periods at the end
        while (processedResultString.endsWith(",") || processedResultString.endsWith(" ") || processedResultString.endsWith(".")) {
            processedResultString = processedResultString.substring(0, processedResultString.length() - 1);
        }
        return processedResultString;
    }

    /**
     * Determines whether a child of a verb in a dependency graph is a plural
     * noun
     * 
     * @param verb the verb to be checked for plural noun children
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return {@code true} if a child of the verb is a plural noun
     * 
     * @see GherkinGenerator#postProcessingOfResultString
     */
    private boolean childIsPluralNoun(IndexedWord verb, CoreSentence sentence) {
        for (IndexedWord child : sentence.dependencyParse().getChildList(verb)) {
            if (child.tag().startsWith("NN") && child.tag().endsWith("S") && !child.word().equalsIgnoreCase("details") && child.index() > verb.index()) {
                // The plural noun must also not be the word “details”, since
                // this is often a verb mistaken as a plural noun, and must be
                // located after the verb.
                return true;
            }
        }
        return false;
    }

    /**
     * Finds the first infinitive-to verb in a sentence.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the first infinitive-to verb, or {@code null} if none is found
     * 
     * @see GherkinGenerator#postProcessingOfResultString
     */
    private IndexedWord getInfinitiveToWord(CoreSentence sentence) {
        for (int i = 1; i < sentence.posTags().size(); i++){
            if (sentence.posTags().get(i).equals("VB") && sentence.posTags().get(i - 1).equals("TO")) {
                // If the word at the 0-based index i is a base form verb and
                // the word at the 0-based index i - 1 is an infinitival “to”,
                // get the verb using its 1-based index and return it.
                return sentence.dependencyParse().getNodeByIndex(i + 1);
            }
        }
        return null;
    }

    /**
     * Finds the first infinitive-to verb in a sentence which is preceeded by
     * an adverb.
     * 
     * @param sentence a {@code CoreSentence} containing the NLP analysis
     * result of the user story
     * @return the first infinitive-to verb preceeded by an adverb, or
     * {@code null} if none is found
     * 
     * @see GherkinGenerator#postProcessingOfResultString
     */
    private IndexedWord getInfinitiveToWordWithAdverb(CoreSentence sentence) {
        for (int i = 2; i < sentence.posTags().size(); i++){
            if (sentence.posTags().get(i).equals("VB") && sentence.posTags().get(i - 1).equals("RB") && sentence.posTags().get(i - 2).equals("TO")) {
                // If the word at the 0-based index i is a base form verb and
                // the word at the 0-based index i - 1 is an adverb and the
                // word at the 0-based index i - 2 is an infinitival “to”, get
                // the verb using its 1-based index and return it.
                return sentence.dependencyParse().getNodeByIndex(i + 1);
            }
        }
        return null;
    }

    /**
     * Removes or replaces information from acceptance criteria that occurs
     * multiple times in different acceptance criteria.
     * 
     * @param acceptanceCriteria a list of acceptance criteria to be resolved
     * @return a list of acceptance criteria without duplicate information
     * 
     * @see GherkinGenerator#generate
     */
    private List<AcceptanceCriterion> resolveDuplicateInformation(List<AcceptanceCriterion> acceptanceCriteria) {
        List<AcceptanceCriterion> resolvedAcceptanceCriteria = new ArrayList<AcceptanceCriterion>();

        String uiDescription = null;

        for (int i = 0; i < acceptanceCriteria.size(); i++) {
            switch (acceptanceCriteria.get(i).getType()) {
                case UI:
                    // If the acceptance criterion is a UI precondition, we
                    // store the UI description string
                    if (uiDescription == null) {
                        uiDescription = acceptanceCriteria.get(i).getRawString();
                    }
                    resolvedAcceptanceCriteria.add(acceptanceCriteria.get(i));
                    break;

                case ACTION:
                    // If the acceptance criterion is an action, we check if
                    // there is another action acceptance criterion following
                    // it.
                    AcceptanceCriterion resolvedAcceptanceCriterion = acceptanceCriteria.get(i);
                    if (i + 1 < acceptanceCriteria.size() && acceptanceCriteria.get(i + 1).getType().equals(AcceptanceCriterionType.ACTION)) {
                        // Check whether the next action is contained in the
                        // current acceptance criterion, and cut the current
                        // acceptance criterion accordingly so that both
                        // acceptance criteria remain and no duplicate
                        // information exists.
                        resolvedAcceptanceCriterion = cutOffAtNextAcceptanceCriterion(resolvedAcceptanceCriterion, acceptanceCriteria.get(i + 1));
                    }
                    // Replace the UI description by a generic expression
                    resolvedAcceptanceCriteria.add(replaceUIDescription(resolvedAcceptanceCriterion, uiDescription));
                    break;

                case RESULT:
                    // Replace the UI description by a generic expression
                    resolvedAcceptanceCriteria.add(replaceUIDescription(acceptanceCriteria.get(i), uiDescription));
                    break;
            
                case ACTION_IN_REASON:
                    // Replace the UI description by a generic expression
                    resolvedAcceptanceCriteria.add(replaceUIDescription(acceptanceCriteria.get(i), uiDescription));
                    break;

                case RESULT_IN_REASON:
                    // Replace the UI description by a generic expression
                    resolvedAcceptanceCriteria.add(replaceUIDescription(acceptanceCriteria.get(i), uiDescription));
                    break;

                default:
                    // Add log messages as is.
                    resolvedAcceptanceCriteria.add(acceptanceCriteria.get(i));
                    break;
            }
        }

        return resolvedAcceptanceCriteria;
    }

    /**
     * Creates an acceptance criterion which contains information from one
     * acceptance criterion and does not contain information from another
     * acceptance criterion, i.e., remove all information contained in the
     * second acceptance criterion from the first acceptance criterion.
     * 
     * @param acceptanceCriterion the acceptance criterion to be cut
     * @param other the acceptance criterion containing information which is
     * to be removed from the first acceptance criterion
     * @return the shortened acceptance criterion
     * 
     * @see GherkinGenerator#resolveDuplicateInformation
     */
    private AcceptanceCriterion cutOffAtNextAcceptanceCriterion(AcceptanceCriterion acceptanceCriterion, AcceptanceCriterion other) {
        if (other.getBeginReplacementIndex() < acceptanceCriterion.getEndReplacementIndex() && acceptanceCriterion.getRawString().indexOf(other.getRawString()) != -1) {
            // if the other acceptance criterion starts before the the first
            // acceptance criterion ends and we can find the raw string of the
            // other acceptance criterion in the raw string of the first
            // acceptance criterion
            
            // cut the first acceptance criterion’s raw string
            String newRawString = acceptanceCriterion.getRawString().substring(0, acceptanceCriterion.getRawString().indexOf(other.getRawString()));
            
            // remove spaces at the end of the cut raw string
            while (newRawString.endsWith(" ")) {
                newRawString = newRawString.substring(0, newRawString.length() - 1);
            }
            for (String conditionalStarterString : conditionalStarterStrings) {
                if (newRawString.endsWith(conditionalStarterString)) {
                    // if we have identified the conditional starter string of
                    // the other acceptance criterion, we remove it
                    newRawString = newRawString.substring(0, newRawString.lastIndexOf(conditionalStarterString));

                    // again, remove spaces at the end of the cut raw string
                    while (newRawString.endsWith(" ")) {
                        newRawString = newRawString.substring(0, newRawString.length() - 1);
                    }        
                    return new AcceptanceCriterion(newRawString, acceptanceCriterion.getType(), acceptanceCriterion.getBeginReplacementIndex(), other.getBeginReplacementIndex() - 1);
                }
            }
        }

        // return the unmodified acceptance criterion, if the acceptance
        // criteria do not overlap or if the conditional starter string of the
        // other acceptance criterion could not be identified and removed.
        return acceptanceCriterion;
    }

    /**
     * Creates an acceptance criterion which replaces a given UI description by
     * a generic expression
     * 
     * @param acceptanceCriterion the acceptance criterion to be modified
     * @param uiDescription the UI description
     * @return the modified acceptance criterion
     * 
     * @see GherkinGenerator#resolveDuplicateInformation
     */
    private AcceptanceCriterion replaceUIDescription(AcceptanceCriterion acceptanceCriterion, String uiDescription) {
        if (uiDescription != null && acceptanceCriterion.getRawString().contains(uiDescription)) {
            // If the acceptance criterion contains the UI description, it is
            // replaced by the words “the active user interface”
            return new AcceptanceCriterion(acceptanceCriterion.getRawString().replace(uiDescription, "the active user interface"), acceptanceCriterion.getType(), acceptanceCriterion.getBeginReplacementIndex(), acceptanceCriterion.getEndReplacementIndex());
        }
        return acceptanceCriterion;
    }

}
